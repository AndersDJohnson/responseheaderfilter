#summary Writing your custom implementation for applying the response headers
With !ResponseHeaderFilter, writing your own custom implementation for applying the rules is very easy. Many a times, you may need to apply response headers based on the request or response. The !ResponseHeaderFilter takes charge of performing the match for a particular mapping (and this functionality cannot be extended). Once a particular {{{<mapping>}}} is found to be a match, your processor class will be invoked to implement the rules in the response headers.

You may define a processor at the *root level* in your config, e.g
{{{
<response-header-mapper processorClass="com.foo.YourClass">
  ...
</response-header-mapper>
}}}
the class specified above would be applicable for all the {{{<mapping>}}}'s in your file. If you need an overriding behavior for a particular mapping, you can define a {{{processorClass}}} attribute for your {{{<mapping>}}}, e.g
{{{
<response-header-mapper processorClass="com.foo.YourClass">
  <mapping url="(.*).js" processorClass="com.foo.YourClassForThisMapping">
    ...
  </mapping>
  ...
</response-header-mapper>
}}}