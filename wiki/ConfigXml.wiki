#summary Understand elements and attributes in the configuration
 * [#Introduction Introduction]
 * [#response-header-mapper response-header-mapper]
  * [#processorClass processorClass] 
 * [#mapping mapping]
  * [#url url]
  * [#processorClass processorClass]
 * [#default default]
 * [#conditional conditional]
  * [#queryParamName queryParamName]
  * [#queryParamValue queryParamValue]
 * [#response-headers response-headers]

= Introduction =
<p>
The file {{{response-header-filter.xml}}} contains instructions for the filter to process requests. It basically contains a set of [#mapping mappings] which are internally processed as [http://code.google.com/p/responseheaderfilter/source/browse/trunk/src/java/com/avlesh/web/filter/responseheaderfilter/Rule.java Rules]. If an incoming request is found to be a match with one of the mappings, the corresponding Rules are applied to the response.
</p>
<p>For a sample mapping file, [SampleConfiguration click here]
The file content is processed according to these rules:
<ol>
<li>The file <b>should</b> have response-header-mapper as the root node.</li>
<li>Each node (in the xml) with the name mapping is identified as mapping rule and
gets converted into a Rule.<br/>url is a mandatory attribute in the mapping node; mappings without a url are rejected.
</li>
<li>Subsequent mappings for the same url will <b>OVERRIDE</b> the previous Rule.
<i>Last Rule wins</i>.
</li>
<li>Each mapping can have only <b>one {{{default}}}</b> response-header list.
In cases of multiple such declarations, the <i>Last `<default>` declaration wins</i>.
</li>
<li>Each mapping can have any number of {{{conditional}}} mappings.
All these rules are treated as mutually exclusive.
</li>
<li>Both, default and conditional nodes <b>should</b> have a `<response-headers>`
node. In case of multiple such nodes, <i>Last `<response-headers>` declaration wins</i>.
</li>
<li>Each `<response-headers>` node may contain one or more `<header>` nodes. Each such node has to have two mandatory attributes, {{{key}}} and {{{value}}}.</li>
<li>Both, {{{queryParamName}}} and {{{queryParamValue}}}, are required attributes in a conditional tag. They <b>can't</b> be left blank or undeclared.
</li>
<li>Values inside the {{{queryParamValue}}} attribute are parsed as a {{{Pattern}}}.</li>
</ol>
</p>

= response-header-mapper =
 * Description: This is the root node for the filter configuration file and is a expected node.
 * Required: Yes
 * Attributes: 
  == processorClass == 
  * Description: A fully qualified class name for the processor class, if you want to process the response headers on your own. You would need a processor class when setting the headers needs to be done after some sort of evaluation over the request and/or response. <br/>Your class should implement the {{{com.avlesh.web.filter.responseheaderfilter.MappingProcessor}}} interface.
  * Required: No
  * Default: {{{com.avlesh.web.filter.responseheaderfilter.DefaultMappingProcessor}}} 

= mapping =
 * Description: A {{{mapping}}} node is set of rules for a matching {{{url}}} pattern.
 * Required: Yes
 * Attributes: 
  == url == 
  * Description: The request {{{uri}}} for which this pattern is valid. Please not that this is *not* supposed to be a request url with complete {{{queryString}}}. All mappings should be done at the base uri level. Conditional mappings might be used to map using query string. Read about those, [#conditional here]
  * Required: No
  * Default: {{{com.avlesh.web.filter.responseheaderfilter.DefaultMappingProcessor}}} 
  == processorClass == 
  * Description: A fully qualified class name for the processor class, if you want to process the response headers on your own. You would need a processor class when setting the headers needs to be done after some sort of evaluation over the request and/or response. <br/>Your class should implement the {{{com.avlesh.web.filter.responseheaderfilter.MappingProcessor}}} interface.
  * Required: No
  * Default: {{{com.avlesh.web.filter.responseheaderfilter.DefaultMappingProcessor}}} 

= default =
 * Description: One of the possible child nodes for a {{{mapping}}} node. Rules specified under default is the default fallback in case of absence of {{{conditional}}} nodes. Each mapping can have only one default. If you specify multiple such default's the last one is respected.
 * Required: No

= conditional =
 * Description: One of the possible child nodes for a {{{mapping}}} node. A {{{mapping}}} node may have many conditional nodes. The conditional nodes can be used to apply specific and different set of rules based on query parameters for the request.
 * Required: No
 * Attributes: 
  == queryParamName == 
  * Description: The query parameter based on which you want to have a {{{conditional}}} rule. e.g. you may want to apply different response headers to {{{/site/log-analyzer.html?type=xxxx}}} based on the {{{type}}} parameter. Your {{{queryParamName}}} in this case would be type.
  * Required: Yes
  == queryParamValue == 
  * Description: In the above example, the value has to be specified in the {{{queryParamValue}}} attribute. This also takes a {{{Pattern}}}.
  * Required: Yes

 * NOTE: *Conditional rules are evaluated from bottom to top. _Last matching rule (in the config) wins_.

<table cellspacing="0" cellpadding="2" border="1" width="700">
 <thead>
  <tr>
   <td width="200">*Node name*</td>
   <td width="200">*Attributes*</td>
   <td width="300">*Description*</td>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td valign="top" width="200">response-header-mapper</td>
   <td valign="top" width="500" colspan="2"><table cellspacing="0" cellpadding="0" border="1" width="500"><tr><td valign="top" width="200">processorClass</td><td valign="top" width="300">1. Description: Class to handle application of response headers.<br/>2. Required: No.<br/>3. Default: [http://code.google.com/p/responseheaderfilter/source/browse/trunk/src/java/com/avlesh/web/filter/responseheaderfilter/DefaultMappingProcessor.java DefaultMappingProcessor]</td>
     </tr>
    </table>
   </td>
  </tr>
  <tr>
   <td valign="top">mapping</td>
   <td valign="top">url</td>
   <td valign="top">  
  # Description: Url pattern for which this mapping should be applied to.
  # Required: Yes
  # Remarks: Similar (read {{{equal}}}) url patterns in the mapping override the previous declaration.
   </td>
  </tr>
 </tbody>
</table>